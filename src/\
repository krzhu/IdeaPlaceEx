#include "legalize_well.hpp"

PROJECT_NAMESPACE_BEGIN

enum class JogOrient_t {
  NE = 0,
  SE = 1,
  SW = 2,
  NW = 3,
  INVALID = 4
};

bool clockwise(const Point<LocType>& p0, const Point<LocType>& p1, const Point<LocType>& p2, JogOrient_t& orient) {
  const LocType path1_deltaX = p1.x() - p0.x();
  const LocType path1_deltaY = p1.y() - p0.y();
  const LocType path2_deltaX = p2.x() - p1.x();
  const LocType path2_deltaY = p2.y() - p1.y();
  if (path1_deltaX > 0 and path1_deltaY == 0 and path2_deltaX == 0 and path2_deltaY < 0) {
    orient = JogOrient_t::NE;
    return true;
  }
  if (path1_deltaX == 0 and path1_deltaY < 0 and path2_deltaX < 0 and path2_deltaY == 0) {
    orient = JogOrient_t::SE;
    return true;
  }
  if (path1_deltaX < 0 and path1_deltaY == 0 and path2_deltaX == 0 and path2_deltaY > 0) {
    orient = JogOrient_t::SW;
    return true;
  }
  if (path1_deltaX == 0 and path1_deltaY > 0 and path2_deltaX > 0 and path2_deltaY == 0) {
    orient = JogOrient_t::NW;
    return true;
  }
  orient = JogOrient_t::INVALID;
  return false;
}

bool counterClockwise(const Point<LocType>& p0, const Point<LocType>& p1, const Point<LocType>& p2, JogOrient_t& orient) {
  const LocType path1_deltaX = p1.x() - p0.x();
  const LocType path1_deltaY = p1.y() - p0.y();
  const LocType path2_deltaX = p2.x() - p1.x();
  const LocType path2_deltaY = p2.y() - p1.y();
  if (path1_deltaX == 0 and path1_deltaY < 0 and path2_deltaX > 0 and path2_deltaY == 0) {
    orient = JogOrient_t::NE;
    return true;
  }
  if (path1_deltaX > 0 and path1_deltaY == 0 and path2_deltaX == 0 and path2_deltaY > 0) {
    orient = JogOrient_t::NW;
    return true;
  }
  if (path1_deltaX == 0 and path1_deltaY > 0 and path2_deltaX < 0 and path2_deltaY == 0) {
    orient = JogOrient_t::SW;
    return true;
  }
  if (path1_deltaX < 0 and path1_deltaY == 0 and path2_deltaX == 0 and path2_deltaY < 0) {
    orient = JogOrient_t::SE;
    return true;
  }
  orient = JogOrient_t::INVALID;
  return false;
}

/// @brief patch the polygon to eliminate concave jogs. 
/// @return if detect jog in the process
bool patchConcaveJogs(LocType minStep, Polygon<LocType>& poly) {
  bool hasJog = false;
  const auto &ring = poly.outer();
  // Here we generate a rectangle for each cell that satisfying the spacing
  // and then we merge them together into a new polygon
  // boost::geometry has a union_ function, but it is not very convenient
  // Here use the boost::polygon implementation
  typedef boost::polygon::property_merge_90<LocType, IntType> PropertyMergeType; //use int as property_type -> we don't care basically
  typedef boost::polygon::polygon_90_set_data<LocType> PolygonSetType; // Potentially we can use our own Polygon set implementation
  // But since we are using boost::geometry outside, it might be safe to explicitly converting boost::polygon polygon back
  typedef std::map<std::set<IntType>, PolygonSetType> PropertyMergeResultType;
  PropertyMergeType pm;
  PropertyMergeResultType result;
  pm.insert(poly, 0);
  for (IndexType j = 1; j < ring.size(); ++j) {
    const auto& pt0 = ring[j - 1];
    const auto& pt1 = ring[j];
    const auto& pt2 = j + 1 == ring.size() ? ring[0] : ring[j + 1];
    if (::klib::manhattanDistance(pt0, pt1) < minStep
        and ::klib::manhattanDistance(pt1, pt2) < minStep) {
      auto box = Box<LocType>(
                     std::min({pt0.x(), pt1.x(), pt2.x()}),
                     std::min({pt0.y(), pt1.y(), pt2.y()}),
                     std::max({pt0.x(), pt1.x(), pt2.x()}),
                     std::max({pt0.y(), pt1.y(), pt2.y()}));
      JogOrient_t orient;
      if (counterClockwise(pt0, pt1, pt2, orient)) { // concave
        hasJog = true;
        pm.insert(box, 0);
        assert(orient != JogOrient_t::INVALID);
      }
    }
  }
  pm.merge(result);
  std::vector<Polygon<LocType>> polyVec;
  (*result.begin()).second.get_polygons(polyVec);
  Assert(polyVec.size() == 1);
  poly.setOuter(polyVec[0].outer());
  return hasJog;
}

/// @brief patch the polygon to eliminate convex jogs
/// @return if detect jog in the process
bool patchConvexJogs(LocType minStep, Polygon<LocType>& poly) {
  bool hasJog = false;
  const auto &ring = poly.outer();
  // Here we generate a rectangle for each cell that satisfying the spacing
  // and then we merge them together into a new polygon
  // boost::geometry has a union_ function, but it is not very convenient
  // Here use the boost::polygon implementation
  typedef boost::polygon::property_merge_90<LocType, IntType> PropertyMergeType; //use int as property_type -> we don't care basically
  typedef boost::polygon::polygon_90_set_data<LocType> PolygonSetType; // Potentially we can use our own Polygon set implementation
  // But since we are using boost::geometry outside, it might be safe to explicitly converting boost::polygon polygon back
  typedef std::map<std::set<IntType>, PolygonSetType> PropertyMergeResultType;
  PropertyMergeType pm;
  PropertyMergeResultType result;
  pm.insert(poly, 0);
  for (IndexType j = 1; j < ring.size(); ++j) {
    const auto& pt0 = ring[j - 1];
    const auto& pt1 = ring[j];
    const auto& pt2 = j + 1 == ring.size() ? ring[0] : ring[j + 1];
    if (::klib::manhattanDistance(pt0, pt1) < minStep
        and ::klib::manhattanDistance(pt1, pt2) < minStep) {
      auto box = Box<LocType>(
                     std::min({pt0.x(), pt1.x(), pt2.x()}),
                     std::min({pt0.y(), pt1.y(), pt2.y()}),
                     std::max({pt0.x(), pt1.x(), pt2.x()}),
                     std::max({pt0.y(), pt1.y(), pt2.y()}));
      JogOrient_t orient;
      if (clockwise(pt0, pt1, pt2, orient)) { // convex
        hasJog = true;
        //_cir.addMaskWire(box, i);
        switch(orient) {
          case JogOrient_t::NE: box.setYH(box.yh() + minStep); break;
          case JogOrient_t::SE: box.setYL(box.yl() - minStep); break;
          case JogOrient_t::SW: box.setYL(box.yl() - minStep); break;  
          case JogOrient_t::NW: box.setYH(box.yh() + minStep); break;
          default: assert(false);
        }
        pm.insert(box, 0);
      }
    }
  }
  pm.merge(result);
  std::vector<Polygon<LocType>> polyVec;
  (*result.begin()).second.get_polygons(polyVec);
  Assert(polyVec.size() == 1);
  poly.setOuter(polyVec[0].outer());
  return hasJog;
}


/// @brief patch the polygon to eliminate u-shape spacing error
/// @return if detect jog in the process
bool patchSpacingJogs(LocType minStep, Polygon<LocType>& poly) {
  bool hasJog = false;
  const auto &ring = poly.outer();
  // Here we generate a rectangle for each cell that satisfying the spacing
  // and then we merge them together into a new polygon
  // boost::geometry has a union_ function, but it is not very convenient
  // Here use the boost::polygon implementation
  typedef boost::polygon::property_merge_90<LocType, IntType> PropertyMergeType; //use int as property_type -> we don't care basically
  typedef boost::polygon::polygon_90_set_data<LocType> PolygonSetType; // Potentially we can use our own Polygon set implementation
  // But since we are using boost::geometry outside, it might be safe to explicitly converting boost::polygon polygon back
  typedef std::map<std::set<IntType>, PolygonSetType> PropertyMergeResultType;
  PropertyMergeType pm;
  PropertyMergeResultType result;
  pm.insert(poly, 0);
  for (IndexType j = 1; j < ring.size(); ++j) {
    const auto& pt0 = ring[j - 1];
    const auto& pt1 = ring[j];
    const auto& pt2 = j + 1 == ring.size() ? ring[0] : ring[j + 1];
    const auto& pt3 = j + 2 == ring.size() ? ring[1] : ring[j + 2];
    if (::klib::manhattanDistance(pt1, pt2) < minStep 
        or (::klib::manhattanDistance(pt0, pt1) < minStep
          and ::klib::manhattanDistance(pt2, pt3) < minStep)) {
      auto box = Box<LocType>(
                     std::min({pt0.x(), pt1.x(), pt2.x(), pt3.x()}),
                     std::min({pt0.y(), pt1.y(), pt2.y(), pt3.y()}),
                     std::max({pt0.x(), pt1.x(), pt2.x(), pt3.x()}),
                     std::max({pt0.y(), pt1.y(), pt2.y(), pt3.y()}));
      JogOrient_t orientA, orientB;
      if (counterClockwise(pt0, pt1, pt2, orientA) and counterClockwise(pt1, pt2, pt3, orientB) ) { // concave
        hasJog = true;
        pm.insert(box, 0);
        Assert(orientA != JogOrient_t::INVALID);
        Assert(orientB != JogOrient_t::INVALID);
      }
    }
  }
  pm.merge(result);
  std::vector<Polygon<LocType>> polyVec;
  (*result.begin()).second.get_polygons(polyVec);
  Assert(polyVec.size() == 1);
  poly.setOuter(polyVec[0].outer());
  return hasJog;
}


BoolType WellLegalizer::legalize() {
  legalizeCellEdgeSpacing();
  legalizeContact();
  legalizeMinStep();
  return true;
}

void WellLegalizer::legalizeMinStep() {
  if (not _db.tech().isNwellLayerSet()) {
    return;
  }
  const LocType minStep = _db.tech().spacingRule(_db.tech().nwellLayerIdx());
  for (IndexType wellIdx = 0; wellIdx < _db.vWells().size(); ++wellIdx) {
    auto &well = _db.well(wellIdx);
    while (1) {
      bool hasJog = false;
      if (patchConcaveJogs(minStep, well.shape())) {
        hasJog = true;
        continue;
      }

      if (patchConvexJogs(minStep, well.shape())) {
        hasJog = true;
        continue;
      }
      if (patchSpacingJogs(minStep, well.shape())) {
        hasJog = true;
        continue;
      }
      if (!hasJog)
        break;
    }
  }
}

void WellLegalizer::generateIndividualWells() {
  _db.clearWells();
  const LocType cellToWellEdgeSpacing = _db.tech().cellToNwellEdgeSpacing();
  for (IndexType cellIdx = 0; cellIdx < _db.numCells(); ++cellIdx) {
    auto &cell = _db.cell(cellIdx);
    if (not cell.needWell()) {
      continue;
    }
    auto cellBox = cell.cellBBoxOff();
    cellBox.expand(cellToWellEdgeSpacing);
    auto wellIdx = _db.allocateWell();
    auto &well = _db.well(wellIdx);
    well.setShape(Polygon<LocType>(cellBox).outer());
    cell.setWellIdx(wellIdx);
    well.addCellIdx(cellIdx);
  }
}

void WellLegalizer::legalizeCellEdgeSpacing() {
  const LocType cellToWellEdgeSpacing = _db.tech().cellToNwellEdgeSpacing();
  for (IndexType wellIdx = 0; wellIdx < _db.vWells().size(); ++wellIdx) {
    auto &well = _db.well(wellIdx);
    // Here we generate a rectangle for each cell that satisfying the spacing
    // and then we merge them together into a new polygon
    // boost::geometry has a union_ function, but it is not very convenient
    // Here use the boost::polygon implementation
    typedef boost::polygon::property_merge_90<LocType, IntType> PropertyMergeType; //use int as property_type -> we don't care basically
    typedef boost::polygon::polygon_90_set_data<LocType> PolygonSetType; // Potentially we can use our own Polygon set implementation
    // But since we are using boost::geometry outside, it might be safe to explicitly converting boost::polygon polygon back
    typedef std::map<std::set<IntType>, PolygonSetType> PropertyMergeResultType;
    PropertyMergeType pm;
    PropertyMergeResultType result;
    pm.insert(well.shape(), 0);
    for (IndexType cellIdx : well.sCellIds()) {
      auto cellBox = _db.cell(cellIdx).cellBBoxOff();
      cellBox.expand(cellToWellEdgeSpacing);
      pm.insert(cellBox, 0);
    }
    pm.merge(result);
    std::vector<Polygon<LocType>> polyVec;
    (*result.begin()).second.get_polygons(polyVec);
    Assert(polyVec.size() == 1);
    well.setShape(polyVec[0].outer());
  }
}

void selectVddContactCandidates(const std::vector<std::pair<Box<LocType>, std::pair<IndexType, LocType>>> &candidates, std::pair<IntType, IntType> costThreshold, std::vector<IndexType> &results) {
  IndexType startIdx = 0;
  IndexType endIdx = 0;
  for (IndexType idx = 0; idx < candidates.size(); ++idx) {
    const auto cost = candidates.at(idx).second.second;
    if (cost < costThreshold.first) {
      ++startIdx;
    }
    if (cost > costThreshold.second) {
      endIdx = idx - 1;
    }
  }
}

/// @brief Try add as many contacts as possible, but make sure add at least one
void legalizeContactByAddingAsManyContactsAsPossible(Database &db, IndexType wellIdx) {
  using rtree_type  = boost::geometry::index::rtree<Box<LocType>, boost::geometry::index::rstar<8, 2>>;
  Well &well = db.well(wellIdx);
  const LocType contactSpacing = db.tech().vddContactSpacing();
  const Polygon<LocType> poly = well.shape();
  std::vector<Box<LocType>> deviceBoxs;
  for (IndexType cellIdx : well.sCellIds()) {
    deviceBoxs.emplace_back(db.cell(cellIdx).cellBBoxOff());
  }
  rtree_type deviceRtree(deviceBoxs); // Store the shape of device
  std::vector<Box<LocType>> outWellDevicesBoxes;
  for (IndexType cellIdx = 0; cellIdx < db.numCells(); ++cellIdx) {
    if (well.sCellIds().find(cellIdx) == well.sCellIds().end()) {
      outWellDevicesBoxes.emplace_back(db.cell(cellIdx).cellBBoxOff());
    }
  }
  rtree_type outDeviceRtree(outWellDevicesBoxes); // Store the out of well devices shapes
  // Generate the contact candidates
  const auto currentWellBBox = well.boundingBox();
  const LocType genStep = std::max(db.parameters().gridStep(), 1);
  const LocType genXLo = genStep * static_cast<LocType>((currentWellBBox.xLo() - contactSpacing)/ genStep);
  const LocType genYLo = genStep * static_cast<LocType>((currentWellBBox.yLo() - contactSpacing)/ genStep);
  const LocType genXHi = genStep * static_cast<LocType>((currentWellBBox.xHi() + contactSpacing)/ genStep + 1);
  const LocType genYHi = genStep * static_cast<LocType>((currentWellBBox.yHi() + contactSpacing)/ genStep + 1);
  std::vector<std::pair<Box<LocType>, std::pair<IndexType, LocType>>> candidates; // .first=shape, second.first = idx, second.second = cost
  IndexType candidateIdx = 0;
  const LocType genStepX = std::max(genStep, (genXHi - genXLo) / 200);
  const LocType genStepY = std::max(genStep, (genYHi - genYLo) / 200);
  for (IndexType contactTemplateIdx = 0; contactTemplateIdx < db.tech().numVddContactTemplates(); ++contactTemplateIdx) {
    const Box<LocType> contactTemplate = db.tech().vddContactTemplate(contactTemplateIdx);
    for (IntType xIdx = 0; xIdx <= (genXHi - genXLo) / genStepX; ++xIdx) {
      for (IntType yIdx = 0; yIdx <= (genYHi - genYLo) / genStepX; ++yIdx) {
        Box<LocType> contactShape = contactTemplate.offsetBox(Point<LocType>(xIdx * genStepX  + genXLo, yIdx * genStepY + genYLo));
        auto queryBox = contactShape;
        queryBox.expand(contactSpacing);
        std::vector<Box<LocType>> queryResults;
        deviceRtree.query(boost::geometry::index::intersects(queryBox), std::back_inserter(queryResults));
        if (not queryResults.empty()) {
          LocType dif = std::max(queryResults.front().yHi() - queryBox.yLo(), 0);
          yIdx += dif / genStepY;
          continue;
        }
        std::vector<Polygon<LocType>> intersects;
        boost::geometry::intersection(contactShape, poly, intersects); // Get the intersection between well and contact

        //DBG("Intersection size %d \n", intersects.size());
        LocType intersectArea = 0;
        for (const auto & inter : intersects) {
          intersectArea += boost::geometry::area(inter);
        }
        //DBG("Area %d \n", intersectArea);
        std::vector<Box<LocType>> outWellIntersects;
        outDeviceRtree.query(boost::geometry::index::intersects(queryBox), std::back_inserter(outWellIntersects)); // Get the intersection between other devices and contact
        LocType outWellDeviceIntersectArea = 0;
        for (const auto &inter : outWellIntersects) {
          outWellDeviceIntersectArea += boost::geometry::area(inter);
        }
        candidates.emplace_back(std::make_pair(contactShape, std::make_pair(candidateIdx, contactShape.area() - intersectArea + outWellDeviceIntersectArea)));
        ++candidateIdx;
      }
    }
  }
  std::stable_sort(candidates.begin(), candidates.end(), [&](const auto &i, const auto &j){ return i.second.second < j.second.second;});
  for (IndexType candIdx = 0; candIdx < candidates.size(); ++candIdx) {
    candidates.at(candIdx).second.first = candIdx;
  }
  IndexType numZeroCost = 0;
  for (IndexType candIdx = 0; candIdx < candidates.size(); ++candIdx) {
    if (candidates.at(candIdx).second.second == 0) {
      numZeroCost += 1;
    }
  }
  if (numZeroCost == 0) {
    AssertMsg(false, "Ok... Then we have to really implment the loop to fix no valid zero cost candidate");
  }
  Assert(false);
}

void WellLegalizer::legalizeContact() {
  if (_db.tech().numVddContactTemplates() == 0) {
    return;
  }
  for (IndexType wellIdx = 0; wellIdx < _db.vWells().size(); ++wellIdx) {
    legalizeContactByAddingAsManyContactsAsPossible(_db, wellIdx);
  }
}

PROJECT_NAMESPACE_END
